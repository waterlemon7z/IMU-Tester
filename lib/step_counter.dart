// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

// Auto-generated initialization code.

final ffi.Pointer<T> Function<T extends ffi.NativeType>(String sym) jniLookup =
    ProtectedJniExtensions.initGeneratedLibrary("step_counter");

/// from: uk.ac.ox.eng.stepcounter.StepCounter
///
/// Created by Jamie Brynes on 1/22/2017.
class StepCounter extends jni.JObject {
  @override
  late final jni.JObjType<StepCounter> $type = type;

  StepCounter.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $StepCounterType();
  static final _new0 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Float)>>(
              "StepCounter__new0")
          .asFunction<jni.JniResult Function(double)>();

  /// from: public void <init>(float samplingFreq)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// [Constructor for the StepCounter module.]
  ///@param samplingFreq [This parameter describes the sampling frequency of the sensor.]
  ///@return [Instance of Step Counter]
  factory StepCounter(
    double samplingFreq,
  ) {
    return StepCounter.fromReference(_new0(samplingFreq).reference);
  }

  static final _start = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "StepCounter__start")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void start()
  ///
  /// [This function starts the Step Counter algorithm.]
  void start() {
    _start(reference.pointer).check();
  }

  static final _stop = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "StepCounter__stop")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void stop()
  ///
  /// [This function stops the Step Counter algorithm. Current behavior is to finish processing all remaining samples before ending the threads.]
  void stop() {
    _stop(reference.pointer).check();
  }

  static final _addOnStepUpdateListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "StepCounter__addOnStepUpdateListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: synchronized public void addOnStepUpdateListener(uk.ac.ox.eng.stepcounter.StepCounter.OnStepUpdateListener listener)
  ///
  /// [This function allows the user to add a callback for when we get a new step!]]
  ///@param listener [Implementation of the OnStepUpdateListener]
  void addOnStepUpdateListener(
    StepCounter_OnStepUpdateListener listener,
  ) {
    _addOnStepUpdateListener(reference.pointer, listener.reference.pointer)
        .check();
  }

  static final _setOnFinishedProcessingListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "StepCounter__setOnFinishedProcessingListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: synchronized public void setOnFinishedProcessingListener(uk.ac.ox.eng.stepcounter.StepCounter.OnFinishedProcessingListener listener)
  void setOnFinishedProcessingListener(
    StepCounter_OnFinishedProcessingListener listener,
  ) {
    _setOnFinishedProcessingListener(
            reference.pointer, listener.reference.pointer)
        .check();
  }

  static final _incSteps = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "StepCounter__incSteps")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: synchronized public void incSteps()
  ///
  /// [This function allows for callbacks to listeners when steps is updated.]
  void incSteps() {
    _incSteps(reference.pointer).check();
  }

  static final _processSample = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("StepCounter__processSample")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void processSample(long time, float[] sample)
  ///
  /// [This function is the public interface to add a new accelerometer sample to the step counter algorithm.]
  ///@param time [The timestamp of the sample in nanoseconds.]
  ///@param sample [An array of accelerometer values [x,y,z] in m/s^2.]
  void processSample(
    int time,
    jni.JArray<jni.jfloat> sample,
  ) {
    _processSample(reference.pointer, time, sample.reference.pointer).check();
  }

  static final _getSteps = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "StepCounter__getSteps")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: synchronized public int getSteps()
  ///
  /// [Getter function for the number steps.]
  ///@return [Returns the number of steps.]
  int getSteps() {
    return _getSteps(reference.pointer).integer;
  }

  static final _getSamplingFreq = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "StepCounter__getSamplingFreq")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getSamplingFreq()
  ///
  /// [Getter function for the sampling frequency.]
  ///@return [Returns the sampling frequency.]
  double getSamplingFreq() {
    return _getSamplingFreq(reference.pointer).float;
  }

  static final _setSamplingFreq = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("StepCounter__setSamplingFreq")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setSamplingFreq(float samplingFreq)
  ///
  /// [Setter function for the sampling frequency.]
  ///@param samplingFreq [The sampling frequency to set.]
  void setSamplingFreq(
    double samplingFreq,
  ) {
    _setSamplingFreq(reference.pointer, samplingFreq).check();
  }
}

final class $StepCounterType extends jni.JObjType<StepCounter> {
  const $StepCounterType();

  @override
  String get signature => r"Luk/ac/ox/eng/stepcounter/StepCounter;";

  @override
  StepCounter fromReference(jni.JReference reference) =>
      StepCounter.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($StepCounterType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($StepCounterType) && other is $StepCounterType;
  }
}

/// from: uk.ac.ox.eng.stepcounter.StepCounter$OnFinishedProcessingListener
class StepCounter_OnFinishedProcessingListener extends jni.JObject {
  @override
  late final jni.JObjType<StepCounter_OnFinishedProcessingListener> $type =
      type;

  StepCounter_OnFinishedProcessingListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $StepCounter_OnFinishedProcessingListenerType();
  static final _onFinishedProcessing = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "StepCounter_OnFinishedProcessingListener__onFinishedProcessing")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onFinishedProcessing()
  ///
  /// This method will get called when the remaining data points finish processing. The owner of the object can make UI adjustments as necessary.
  void onFinishedProcessing() {
    _onFinishedProcessing(reference.pointer).check();
  }
}

final class $StepCounter_OnFinishedProcessingListenerType
    extends jni.JObjType<StepCounter_OnFinishedProcessingListener> {
  const $StepCounter_OnFinishedProcessingListenerType();

  @override
  String get signature =>
      r"Luk/ac/ox/eng/stepcounter/StepCounter$OnFinishedProcessingListener;";

  @override
  StepCounter_OnFinishedProcessingListener fromReference(
          jni.JReference reference) =>
      StepCounter_OnFinishedProcessingListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($StepCounter_OnFinishedProcessingListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($StepCounter_OnFinishedProcessingListenerType) &&
        other is $StepCounter_OnFinishedProcessingListenerType;
  }
}

/// from: uk.ac.ox.eng.stepcounter.StepCounter$OnStepUpdateListener
///
/// This is the interface for getting updates when we get a step occuring. Simple listener/broadcaster pattern.
class StepCounter_OnStepUpdateListener extends jni.JObject {
  @override
  late final jni.JObjType<StepCounter_OnStepUpdateListener> $type = type;

  StepCounter_OnStepUpdateListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $StepCounter_OnStepUpdateListenerType();
  static final _onStepUpdate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("StepCounter_OnStepUpdateListener__onStepUpdate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onStepUpdate(int steps)
  ///
  /// This method will be called by a background thread and hence any UI changes done in the implementation of this MUST be done in the runInUiThread() way.
  void onStepUpdate(
    int steps,
  ) {
    _onStepUpdate(reference.pointer, steps).check();
  }
}

final class $StepCounter_OnStepUpdateListenerType
    extends jni.JObjType<StepCounter_OnStepUpdateListener> {
  const $StepCounter_OnStepUpdateListenerType();

  @override
  String get signature =>
      r"Luk/ac/ox/eng/stepcounter/StepCounter$OnStepUpdateListener;";

  @override
  StepCounter_OnStepUpdateListener fromReference(jni.JReference reference) =>
      StepCounter_OnStepUpdateListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($StepCounter_OnStepUpdateListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($StepCounter_OnStepUpdateListenerType) &&
        other is $StepCounter_OnStepUpdateListenerType;
  }
}
